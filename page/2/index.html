<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">















  <link rel="alternate" href="/atom.xml" title="Fynn's Blog">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.6.0" />



<link rel="canonical" href="https://fynn90.github.io/page/2/"/>


<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.6.0" />



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />




  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?607980a031d3edcefed502ce80e77ffb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



  <script id="google_analytics">
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-115728733-1', 'auto');
        ga('send', 'pageview');
  </script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "jH321kB4p1r5FNrL8YBCwbrG-gzGzoHsz",
      appKey: "Q8vnaBtTzmVPbVX8tdzM7z7w"
    });
  </script>





    <title> Fynn's Blog </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Fynn's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/categories/">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">Fynn's Blog</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories/">
            
            
              分类
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  <section id="posts" class="posts">
    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/09/10/Object.defineProperty/">Object.defineProperty</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-10
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Javascript/">Javascript</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/09/10/Object.defineProperty/"
             data-title="Object.defineProperty">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p><code>Object.defineProperty</code>可以用来给<code>Object</code>增加新的属性或更新已有属性,并返回该<code>Object</code>.</p>
<p><code>Object.defineProperty</code>并不单单只是让我们手动给<code>Object</code>添加或修改属性值,它最大的特点是我们可以给对象单个属性值添加属性描述符(PropertyDescriptor).</p>
<p>属性描述符可以给当前对象属性添加额外的一些功能,例如:是否可以被修改、是否可以被枚举、捕获该属性的值的变化和读取.</p>
<p><em>注意: 冻结一个对象属性操作可以用 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener"><code>Object.freeze()</code></a></em></p>
<p><em>注意: 可以用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener">Object.defineProperties</a>批量给对象添加或修改属性描述符</em></p>
          <div class="read-more">
            <a href="/2019/09/10/Object.defineProperty/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/09/09/window.requestAnimationFrame/">requestAnimationFrame</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-09
        </span>
        
          <div class="post-category">
            
              <a href="/categories/BOM/">BOM</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/09/09/window.requestAnimationFrame/"
             data-title="requestAnimationFrame">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>在制作页面动画时,我们可以通过定时器(<code>setTimeout</code>或<code>setInterval</code>)循环操作DOM节点来实现动画的效果.</p>
<p>但是<a href="https://developers.google.com/web/fundamentals/performance/rendering/optimize-javascript-execution?hl=zh-tw" target="_blank" rel="noopener">Google 最佳JS实践</a>要求使用<code>requestAnimationFrame</code>代替定时器.这是为什么呢?</p>
<p>原因有三个:</p>
<ol>
<li><code>setTimeout\setInterval</code>并不和JS在一个线程上,虽然你可以模拟浏览器刷新频率(1000/60),但如果JS线程执行时间较长,JS出超过这个时间去保存有<code>setTimeout\setInterval</code>回调的队列中拿回调执行.这个时候页面会出现卡顿的情况.</li>
<li>在一些浏览器中,运行有<code>setTimeout\setInterval</code>的脚本的页面,即使当前未被打开,定时器脚本依然是在后台运行的.这就浪费了计算机资源.</li>
<li>并不是所有的浏览器都是每秒60帧频率,所以<code>setTimeout\setInterval</code>的定时时间需要适配设备.</li>
</ol>
<p>用<code>requestAnimationFrame</code>就不会有上面这三个问题!</p>
          <div class="read-more">
            <a href="/2019/09/09/window.requestAnimationFrame/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/09/02/设计模式-状态模式/">设计模式-状态模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-09-02
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/09/02/设计模式-状态模式/"
             data-title="设计模式-状态模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>状态模式是一种行为软件设计模式.一个对象在其内部状态改变时会改变它的行为.各种状态和状态改变行为的操作是被独立封装的..</p>
<p>一般情况是:如果一个事物有多钟状态,我们用一个变量保存当前状态名(string),通过<code>if-else</code> 做状态的判断,然后进行状态的变更.</p>
<p>这样最大的问题是: 你需要将所有的状态和变更状态后的行为都放在一个方法里.这个方法会变得很臃肿和复杂.会变的难以阅读和维护.</p>
<p>状态模式:将各种状态和状态之间切换的行为封装在一起.只需要一个Context来触发状态变化,而状态变化后引起的行为操作Context不用处理.</p>
<p>状态模式的优点:</p>
<ol>
<li>状态和行为关系封装在一起,增加新的状态和状态转换会很容易</li>
<li>对象代替字符串保存当前状态,状态的可切换一目了然</li>
<li>避免了Context无限膨胀</li>
<li>Context中的请求动作和状态类中封装的行为非常容易,它们独立变化而不互相影响</li>
</ol>
<p>状态模式的缺陷:</p>
<ol>
<li>逻辑分散在状态类中,虽然避免的条件分支但也导致了逻辑分散问题</li>
<li>新增了封装状态和行为变化的对象,增加了代码量.</li>
</ol>
          <div class="read-more">
            <a href="/2019/09/02/设计模式-状态模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/25/设计模式-装饰者模式/">设计模式-装饰者模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-25
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/08/25/设计模式-装饰者模式/"
             data-title="设计模式-装饰者模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>饰模式是种动态的向一个类(方法)添加行为的设计模式.它不会直接修改原类(方法).</p>
<p>装饰模式比生成子类更灵活,它不会影响原来的类(方法),可以增对单独的方法增加新的行为.</p>
<blockquote>
<p>在面向对象的编程中，装饰器模式是一种设计模式，它允许将行为静态或动态地添加到单个对象，而不会影响同一类中其他对象的行为。装饰器模式通常用于遵守单一责任原则，因为它允许在具有独特关注区域的类之间划分功能。</p>
</blockquote>
          <div class="read-more">
            <a href="/2019/08/25/设计模式-装饰者模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/23/设计模式-职责链模式/">设计模式-职责链模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-23
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/08/23/设计模式-职责链模式/"
             data-title="设计模式-职责链模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>职责链模式是一种行为型设计模式,它将一些列可能会处理请求的对象连接成在一起,请求在这些对象间传递,直到遇到可以处理它的对象.这些处理请求的对象称为链中的节点.</p>
<p>职责链模式优点:</p>
<ul>
<li>解耦请求的发送者和N个接受者之间复杂关系.</li>
<li>手动指定起始节点.</li>
<li>链中的节点对象可以灵活拆分重组.</li>
</ul>
<p><strong>注意:</strong> 职责链模式有个缺陷是,大部分的节点并没有实质的作用,它们的作用仅仅是让请求传递下去,从性能方面考虑我们要避免过长的职责链带来的性能消耗.</p>
<p>职责链模式可以很好地帮助我们管理代码,降低发起请求的对象和处理请求对象之间的耦合性.</p>
<p><img src="https://i.loli.net/2019/08/22/LxpzCP1cETB9SnX.png" alt="5bd5b48157043.png"><br>
          <div class="read-more">
            <a href="/2019/08/23/设计模式-职责链模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/22/设计模式-中介者模式/">设计模式-中介者模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-22
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/08/22/设计模式-中介者模式/"
             data-title="设计模式-中介者模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>中介者模式是一种行为型设计模式,它的目的是通过增加一个中介对象,解除对象与对象之间的紧耦合关系.</p>
<p>增加中介对象后,所有的相关对象都通过中介对象来通信,而不是互相引用,所有当一个对象发生改变时,只需要通知中介者对象即可.</p>
<p><img src="https://i.loli.net/2019/08/22/N9zC85GOMHRdxnl.png" alt="mediator-pattern22.png"><br>
          <div class="read-more">
            <a href="/2019/08/22/设计模式-中介者模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/20/设计模式-享元模式/">设计模式-享元模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-20
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/08/20/设计模式-享元模式/"
             data-title="设计模式-享元模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>享元模式(Flyweight)是一种软件设计模式.是通过将类似的对象进行共享,达到最小化内存的使用对象.</p>
<p>享元模式要求将对象的属性划分为内部状态(不会改变属性)和外部状态(会动态变化的属性).享元模式的目标是尽量减少共享对象的数量.它的关键点是划分内部状态和外部状态.</p>
<p>享元模式特点:</p>
<ul>
<li>内部状态存储于对象内部</li>
<li>内部状态可以被一些对象共享</li>
<li>内部状态独立于具体的场景,通常不会变化</li>
<li>外部状态取决于具体的场景,并根据场景而变化,外部状态不会被共享.</li>
</ul>
<p><strong>注意:</strong> 享元模式是一种用时间换空间的优化模式.<br>
          <div class="read-more">
            <a href="/2019/08/20/设计模式-享元模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/19/设计模式-模板方法模式/">设计模式-模板方法模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-19
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/08/19/设计模式-模板方法模式/"
             data-title="设计模式-模板方法模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>模板方法模式是一种行为设计模式,它是需要通过继承实现的设计模式.</p>
<p>模板方法模式有两个部分组成.</p>
<ol>
<li>抽象父类.它定义了算法操作框架和具体的算法执行流程.(一般在父类定义 init 方法作执行算法)</li>
<li>具体实现抽象父类的子类. 子类实现了父类定义的算法结构,但最后的执行通过父类实现的方法执行.</li>
</ol>
<p><strong>注意:</strong> 父类只负责定义算法框架,具体实现有子类完成.不同的子类,实现抽象类定义的抽象方法可以不同,但子类不应该改变算法的执行步骤!<br>
          <div class="read-more">
            <a href="/2019/08/19/设计模式-模板方法模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/19/设计模式-适配器模式/">设计模式-适配器模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-19
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/08/19/设计模式-适配器模式/"
             data-title="设计模式-适配器模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>适配器模式是一种很简单的软件设计模式,它允许将现有的类(方法)用作另一个接口.它通常用于使现有类(方法)与其他类(方法)一起工作而无需修改其源码.</p>
<p>适配器模式看起和装饰者模式、代理模式看起来很像.但它们在设计目的上还是有不同的:</p>
<ul>
<li>适配器模式主要是用来解决两个已有接口之间不匹配的问题,它不考虑这些接口具体的实现,也不考虑它们将如何演化.适配器不需要改变已有的接口,就能够使它们协同作用.</li>
<li>装饰者模式和代理模式也不会改变原有对象的接口,但装饰者模式的作用是为了给对象增加功能.代理模式是为了控制对象的访问,通常也只包装一次.</li>
</ul>
          <div class="read-more">
            <a href="/2019/08/19/设计模式-适配器模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/16/设计模式-组合模式/">设计模式-组合模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-16
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/08/16/设计模式-组合模式/"
             data-title="设计模式-组合模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>组合模式是一种结构型设计模式,组合模式将对象以树形结构组合在一起,每一个对象具有相同的属性和方法.组合模式允许客户用统一的方式处理单个对象.</p>
<p>组合模式的特点:</p>
<ol>
<li>表示树形结构.可以非常方便描述对象部分-整体层次结构.</li>
<li>利用对象多态性统一对待组合对象和单个对象.在组合模式中,使用者将统一地使用组合结构中的所有对象,而不用关心它究竟是组合对象还是单个对象.</li>
</ol>
          <div class="read-more">
            <a href="/2019/08/16/设计模式-组合模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/15/设计模式-命令模式/">设计模式-命令模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-15
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/08/15/设计模式-命令模式/"
             data-title="设计模式-命令模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>命令模式(Command pattern)是一种行为设计模式,它封装的对象包含稍后执行所需要的方法名和该方法需要的参数.</p>
<p>命令对象发送者和接受者并不知道彼此,他们也不关心.这样就将可以消除的发送者和接受者之间的耦合关系.</p>
<p>命令模式带来的好处有:</p>
<ol>
<li>重复多次操作(例如:重复下单)</li>
<li>取消操作(例如:下的订单取消掉)</li>
<li>取消后重做操作(例如:订单的支付取消,然后再进行支付)</li>
<li>操作行为回溯(例如:象棋中的悔棋操作)
          <div class="read-more">
            <a href="/2019/08/15/设计模式-命令模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/06/设计模式-发布_订阅模式/">设计模式-发布-订阅模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-06
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/08/06/设计模式-发布_订阅模式/"
             data-title="设计模式-发布-订阅模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <blockquote>
<p>发布-订阅模式.又称观察者模式(Observer).它定义了对象之间的一对一或一对多的依赖关系.当一个对象发生变化时,它会通知到依赖它的其他对象.</p>
</blockquote>
<p>发布-订阅模式广泛用于异步编程者中,是一种代替传递回调函数的方案.前端最典型的例子就是:<code>EventTarget.addEventListener()</code>监听DOM事件.</p>
<p>发布-订阅模式可以取代对象之间的硬编码,让两个对象松耦合联系在一起.</p>
<p>发布订阅模式的缺陷:</p>
<ol>
<li>会消耗一定的时间和内存.</li>
<li>过度使用会将对象之间的联系深埋在背后,导致程序难以跟踪维护和理解.
          <div class="read-more">
            <a href="/2019/08/06/设计模式-发布_订阅模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/08/04/设计模式-代理模式/">设计模式-代理模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-08-04
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/08/04/设计模式-代理模式/"
             data-title="设计模式-代理模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <blockquote>
<p>代理模式:通过一个中间对象,控制对真实想要调用对象的访问.</p>
</blockquote>
<p>代理模式的用途:</p>
<ol>
<li>代理将接受的信息 加工处理后传给本体,还可以控制本体接受数据的速率.</li>
<li>代理帮助缓存本体已经处理过的数据.</li>
<li>代理校验是否有权限访问本体.</li>
</ol>
          <div class="read-more">
            <a href="/2019/08/04/设计模式-代理模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/07/27/设计模式-策略模式/">设计模式-策略模式</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-07-27
        </span>
        
          <div class="post-category">
            
              <a href="/categories/设计模式/">设计模式</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/07/27/设计模式-策略模式/"
             data-title="设计模式-策略模式">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>软件设计模式是高效组织代码的方式,它能保证系统的灵活性和可靠性.策略模式是最长用的模式之一.</p>
<blockquote>
<p>定义一系列的算法,把它们封装起来.并且使它们可以互相替换. - 策略模式</p>
</blockquote>
          <div class="read-more">
            <a href="/2019/07/27/设计模式-策略模式/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/07/17/Node.JS自动打包部署脚本/">Node.JS自动打包部署脚本</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-07-17
        </span>
        
          <div class="post-category">
            
              <a href="/categories/TypeScript/">TypeScript</a>
            
              <a href="/categories/TypeScript/Node-js/">Node.js</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/07/17/Node.JS自动打包部署脚本/"
             data-title="Node.JS自动打包部署脚本">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>前端工程化的一个基础能力就是自动部署前端打包后的代码到服务器.基于node和typecript写了一个自动部署的脚步.</p>
<p>脚本的逻辑是先将目录打包压缩包,再通过SSH上传到服务器,最后解压和备份.<a href="https://github.com/fynn90/node-deploy-script" target="_blank" rel="noopener">源码地址</a></p>
<p><img src="https://i.loli.net/2019/07/17/5d2ef632b8e1f76645.png" alt="图片"><br>
          <div class="read-more">
            <a href="/2019/07/17/Node.JS自动打包部署脚本/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/07/13/浏览器的Even Loop和Node.JS的Even Loop/">浏览器和Node.js中的Event Loop</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-07-13
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Javascript/">Javascript</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/07/13/浏览器的Even Loop和Node.JS的Even Loop/"
             data-title="浏览器和Node.js中的Event Loop">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <blockquote>
<p>“Event Loop是一个程序结构，用于等待和发送消息和事件。（a programming construct that waits for and dispatches events or messages in a program.）”</p>
</blockquote>
<p>JS是一门单线程语言,但它支持事件驱动,可以同时接受多个事件并处理响应.这个处理过程是异步操作的. 在浏览器和Node.js中实现了一套 Event Loop机制来完成 JS的异步操作行为.<br>
          <div class="read-more">
            <a href="/2019/07/13/浏览器的Even Loop和Node.JS的Even Loop/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/06/03/Dart最佳实践/">Dart最佳实践</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-06-03
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Dart/">Dart</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/06/03/Dart最佳实践/"
             data-title="Dart最佳实践">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>一个项目中会有多名开发中同时进行code,为了项目的健壮和可维护性我们需要制定一套代码规范,约束开发者的coding.</p>
<p>Dart官方推荐一套代码规范.这套规范适用于其他语言的项目代码规范.</p>
          <div class="read-more">
            <a href="/2019/06/03/Dart最佳实践/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/06/02/Dart语言/">Dart语言</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-06-02
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Programming-language/">Programming language</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/06/02/Dart语言/"
             data-title="Dart语言">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p><a href="https://dart.dev/" target="_blank" rel="noopener"><strong>Dart</strong></a> 是Google为客户端界面开发而创造的静态语言.它是<a href="https://flutter.dev/" target="_blank" rel="noopener"><strong>Flutter</strong></a>框架指定的开发语言.</p>
<p><img src="https://i.loli.net/2019/05/28/5cece296e974b53811.png" alt=""></p>
          <div class="read-more">
            <a href="/2019/06/02/Dart语言/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/05/23/Http缓存机制/">HTTP缓存机制</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-05-23
        </span>
        
          <div class="post-category">
            
              <a href="/categories/网络/">网络</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/05/23/Http缓存机制/"
             data-title="HTTP缓存机制">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <blockquote>
<p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术.</p>
</blockquote>
<p>Web 缓存能够减少延迟与网络阻塞，进而减少显示某个资源所用的时间。借助 HTTP 缓存，Web 站点变得更具有响应性。</p>
<p>缓存技术有: 网关缓存、CDN、方向代理缓存、负载均衡器等部署在服务器端的缓存技术.</p>
<p>HTTP缓存是浏览器和服务器协同工作完成的一种机制.它可以帮助Web应用更开始的响应用户的行为.</p>
<p>而在HTTP缓存中只能存储GET请求的响应,对于其他类型的响应无能为力.</p>
          <div class="read-more">
            <a href="/2019/05/23/Http缓存机制/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
      
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          <a class="post-link" href="/2019/05/06/Linux用户和权限管理/">Linux用户和权限管理</a>
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2019-05-06
        </span>
        
          <div class="post-category">
            
              <a href="/categories/Linux/">Linux</a>
            
          </div>
        
        
        <div class="post-visits"
             data-url="/2019/05/06/Linux用户和权限管理/"
             data-title="Linux用户和权限管理">
            阅读次数
          </div>
        
      </div>
    </header>

    
    

    <div class="post-content">
      
        
        
          
        

        
          <p>Linux账户体系分为用户和群组,一个用户可以属于多个群组.而Linux里面一切皆是文件,而对文件的权限分为三类:<strong>拥有者</strong>,<strong>群组</strong>,<strong>其他</strong>.</p>
<p>针对不同的用户需求,应该创建不同的账户和群组.使它们只能针对特定的文件或目录拥有权限,这样最大限度的保证系统的安全.</p>
          <div class="read-more">
            <a href="/2019/05/06/Linux用户和权限管理/" class="read-more-link">阅读更多</a>
          </div>
        
      
    </div>

    

    

  </article>

    
  </section>

  
  <nav class="pagination">
    
      <a class="prev" href="/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">上一页</span>
      </a>
    
    
      <a class="next" href="/page/3/">
        <span class="next-text">下一页</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


          </div>
          

        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:fynn.90@outlook.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
        
          <a href="https://www.linkedin.com/in/%E5%B8%86-%E9%82%93-17163589/" class="iconfont icon-linkedin" title="linkedin"></a>
        
      
    
      
        
          <a href="https://plus.google.com/u/0/117459332873536225443" class="iconfont icon-google" title="google"></a>
        
      
    
      
        
          <a href="https://github.com/fynn90" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="http://www.weibo.com/306019091" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
        
          <a href="https://www.zhihu.com/people/FynnDeng/activities" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    
    
    
  </div>


<div class="copyright">
  <span class="copyright-year">
    
    &copy; 
     
      2017 - 
    
    2021

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">Fynn</span>
  </span>
  
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    


    
  





  
    <script type="text/javascript" src="/lib/jquery/jquery-3.1.1.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  


    <script type="text/javascript" src="/js/src/even.js?v=2.6.0"></script>
<script type="text/javascript" src="/js/src/bootstrap.js?v=2.6.0"></script>

  </body>
</html>
